#include "gfpch.h"
#include "Graphite/Viewport/Viewport.h"
#include <imgui.h>
#include "glm/gtc/matrix_transform.hpp"

#include "Graphite/Renderer/Renderer2D.h"

namespace Graphite
{
	Viewport::Viewport(const std::string& viewportName, uint32_t width, uint32_t height, bool initialize)
		: m_Name(viewportName), m_ViewportSize({ width, height }), m_CameraController(1280.0f / 720.0f, true)
	{
		// Define framebuffer specification with color format
		m_fbSpec.Width = width;
		m_fbSpec.Height = height;
		m_fbSpec.Attachments = { FramebufferTextureFormat::RGBA8, FramebufferTextureFormat::DEPTH24STENCIL8 };

		if (initialize)
			init();
	}

	Viewport::~Viewport() {}

	void Viewport::init() {

		

		// Square 
		m_SquareVA = Graphite::VertexArray::Create();

		float squareVertices[5 * 4] = {
			-0.5f, -0.5f, 0.0f, 0.0f, 0.0f,
			 0.5f, -0.5f, 0.0f, 1.0f, 0.0f,
			 0.5f,  0.5f, 0.0f, 1.0f, 1.0f,
			-0.5f,  0.5f, 0.0f, 0.0f, 1.0f
		};

		Graphite::Ref<Graphite::VertexBuffer> squareVB = Graphite::VertexBuffer::Create(squareVertices, sizeof(squareVertices));
		squareVB->SetLayout({
			{ Graphite::ShaderDataType::Float3, "a_Position" },
			{ Graphite::ShaderDataType::Float2, "a_TexCoord" }
			});
		m_SquareVA->AddVertexBuffer(squareVB);

		uint32_t squareIndices[6] = { 0, 1, 2, 2, 3, 0 };
		Graphite::Ref<Graphite::IndexBuffer> squareIB = Graphite::IndexBuffer::Create(squareIndices, sizeof(squareIndices) / sizeof(uint32_t));
		m_SquareVA->SetIndexBuffer(squareIB);

		m_Texture = Graphite::Texture2D::Create("assets/textures/Checkerboard.png");
		m_ChernoLogoTexture = Graphite::Texture2D::Create("assets/textures/ChernoLogo.png");

		// Load shader file and bind the shader
		auto textureShader = m_ShaderLibrary.Load("assets/shaders/Texture.glsl");
		textureShader->Bind();
		// Set up framebuffer
		if (!m_Initialized) {
			m_Framebuffer = Framebuffer::Create(m_fbSpec);
			m_Initialized = true;
		}
	}

	void Viewport::Resize(uint32_t width, uint32_t height) {
		if (m_Framebuffer && (width != m_fbSpec.Width || height != m_fbSpec.Height)) {
			m_fbSpec.Width = width;
			m_fbSpec.Height = height;
			m_Framebuffer->Resize(width, height);
		}
	}

	void Viewport::process(Timestep ts) {
		GF_PROFILE_FUNCTION();

		// Update
		m_CameraController.OnUpdate(ts);

		// Render
		m_Framebuffer->Bind();

		Graphite::RenderCommand::SetClearColor({ 0.1f, 0.1f, 0.1f, 1 });
		Graphite::RenderCommand::Clear();

		Graphite::Renderer::BeginScene(m_CameraController.GetCamera());

		// Get the Texture shader
		auto textureShader = m_ShaderLibrary.Get("Texture");

		// Set uniform values
		textureShader->SetFloat4("u_Color", { 1.0f, 1.0f, 1.0f, 1.0f });	// Set the tint color for texture
		textureShader->SetFloat("u_TilingFactor", 1.0f);		// Set the tiling factor
		textureShader->SetInt("u_Texture", 0);	// Bind the u_Texture to slot 0

		m_Texture->Bind(0);
		Graphite::Renderer::Submit(textureShader, m_SquareVA, glm::scale(glm::mat4(1.0f), glm::vec3(1.5f)));


		Graphite::Renderer::EndScene();

		m_Framebuffer->Unbind();
	}

	void Viewport::renderViewport() {
		GF_PROFILE_FUNCTION();

		ImGui::Begin("Viewport");
		auto textureID = m_Framebuffer->GetColorAttachmentRendererID();
		ImGui::Image((ImTextureID)(intptr_t)textureID, ImVec2{ m_ViewportSize.x, m_ViewportSize.y }, ImVec2{ 0, 1 }, ImVec2{ 1, 0 });
		ImGui::End();
	}
}
